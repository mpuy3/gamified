<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Sphere with Repelling Lobes</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
      import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

      let scene, camera, renderer, controller;
      const lobes = [];
      const lobeDistance = 0.15;
      const sphereRadius = 0.1;
      let centralSphere;

      const raycaster = new THREE.Raycaster();
      const tap = new THREE.Vector2();

      let rotationEnabled = false;
      let lastTouchPosition = new THREE.Vector2();

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        window.addEventListener('click', onClick);

        renderer.setAnimationLoop(() => {
          TWEEN.update();
          renderer.render(scene, camera);
        });

        // Add central sphere
        centralSphere = createSphere(new THREE.Vector3(0, 0, -0.5), 0x3366ff);
        scene.add(centralSphere);

        // Add touch event listeners for rotating the model
        renderer.xr.addEventListener('selectstart', onSelectStart);
        renderer.xr.addEventListener('selectend', onSelectEnd);
      }

      function createSphere(position, color = 0xff0000, radius = sphereRadius) {
        const geometry = new THREE.SphereGeometry(radius, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        return sphere;
      }

      function createLobe(position, direction) {
        const geometry = new THREE.SphereGeometry(0.035, 16, 16); // Bigger lobe
        geometry.scale(1, 2.2, 1); // More elongated
        const material = new THREE.MeshStandardMaterial({ color: 0xff6699 });
        const lobe = new THREE.Mesh(geometry, material);
        lobe.userData.isLobe = true;

        // Orient the lobe so its long axis (Y) aligns with the direction
        const up = new THREE.Vector3(0, 1, 0);
        const quat = new THREE.Quaternion().setFromUnitVectors(up, direction.clone().normalize());
        lobe.quaternion.copy(quat);

        lobe.position.copy(position);
        lobe.scale.set(0.01, 0.01, 0.01);
        scene.add(lobe);
        lobes.push(lobe);

        new TWEEN.Tween(lobe.scale)
          .to({ x: 1, y: 1, z: 1 }, 300)
          .easing(TWEEN.Easing.Quadratic.Out)
          .start();
      }

      function onClick(event) {
        if (!renderer.xr.isPresenting) return;

        tap.x = (event.clientX / window.innerWidth) * 2 - 1;
        tap.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(tap, camera);
        const intersects = raycaster.intersectObjects([centralSphere, ...lobes]);

        if (intersects.length > 0) {
          const intersect = intersects[0];

          if (intersect.object === centralSphere && lobes.length < 8) {
            const localPoint = intersect.point.clone().sub(centralSphere.position).normalize();
            const lobePos = centralSphere.position.clone().add(localPoint.clone().multiplyScalar(lobeDistance));
            createLobe(lobePos, localPoint);
            repelLobes3D();
          } else if (intersect.object.userData.isLobe) {
            const index = lobes.indexOf(intersect.object);
            if (index > -1) {
              const lobe = lobes[index];
              lobes.splice(index, 1);

              new TWEEN.Tween(lobe.scale)
                .to({ x: 0.01, y: 0.01, z: 0.01 }, 300)
                .easing(TWEEN.Easing.Quadratic.In)
                .onComplete(() => scene.remove(lobe))
                .start();

              repelLobes3D();
            }
          }
        }
      }

      function onSelect() {
        // no-op
      }

      function repelLobes3D() {
        const count = lobes.length;
        if (count === 0) return;

        // Fix angle distribution for fewer lobes (e.g., two lobes)
        lobes.forEach((lobe, i) => {
          const phi = count > 2 ? Math.acos(-1 + (2 * (i + 1)) / (count + 1)) : Math.PI * i / (count / 2);  // Evenly spaced for low counts
          const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 1); // golden angle

          const x = Math.cos(theta) * Math.sin(phi);
          const y = Math.sin(theta) * Math.sin(phi);
          const z = Math.cos(phi);

          const direction = new THREE.Vector3(x, y, z).normalize();
          const targetPos = centralSphere.position.clone().add(direction.clone().multiplyScalar(lobeDistance));

          new TWEEN.Tween(lobe.position)
            .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 300)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();

          // Also rotate to align to new direction
          const up = new THREE.Vector3(0, 1, 0);
          const quat = new THREE.Quaternion().setFromUnitVectors(up, direction);
          lobe.quaternion.copy(quat);
        });
      }

      function onSelectStart(event) {
        if (event.data && event.data.originalEvent && event.data.originalEvent.touches && event.data.originalEvent.touches.length === 2) {
          rotationEnabled = true;
          lastTouchPosition.set(event.data.originalEvent.touches[0].clientX, event.data.originalEvent.touches[0].clientY);
        }
      }

      function onSelectEnd(event) {
        rotationEnabled = false;
      }

      renderer.xr.getController(0).addEventListener('select', function (event) {
        if (rotationEnabled) {
          const touchPosition = new THREE.Vector2(
            event.data.originalEvent.touches[0].clientX,
            event.data.originalEvent.touches[0].clientY
          );

          const deltaX = touchPosition.x - lastTouchPosition.x;
          const deltaY = touchPosition.y - lastTouchPosition.y;

          if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
            const rotationSpeed = 0.005;
            centralSphere.rotation.y += deltaX * rotationSpeed;
            centralSphere.rotation.x += deltaY * rotationSpeed;
          }

          lastTouchPosition.set(touchPosition.x, touchPosition.y);
        }
      });

    </script>
  </body>
</html>
