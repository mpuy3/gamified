<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Sphere with Repelling Lobes</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
      import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

      let scene, camera, renderer, controller, touchStartRotation, touchStartPosition;
      const lobes = [];
      const lobeDistance = 0.15;
      const sphereRadius = 0.1;
      let centralSphere;

      const raycaster = new THREE.Raycaster();
      const tap = new THREE.Vector2();

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        window.addEventListener('click', onClick);
        window.addEventListener('touchstart', onTouchStart, { passive: true });
        window.addEventListener('touchmove', onTouchMove, { passive: true });
        window.addEventListener('touchend', onTouchEnd, { passive: true });

        renderer.setAnimationLoop(() => {
          TWEEN.update();
          renderer.render(scene, camera);
        });

        // Add central sphere
        centralSphere = createSphere(new THREE.Vector3(0, 0, -0.5), 0x3366ff);
        scene.add(centralSphere);
      }

      function createSphere(position, color = 0xff0000, radius = sphereRadius) {
        const geometry = new THREE.SphereGeometry(radius, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        return sphere;
      }

      function createLobe(position, direction) {
        const geometry = new THREE.SphereGeometry(0.035, 16, 16); // Bigger lobe
        geometry.scale(1, 2.2, 1); // More elongated
        const material = new THREE.MeshStandardMaterial({ color: 0xff6699 });
        const lobe = new THREE.Mesh(geometry, material);
        lobe.userData.isLobe = true;

        // Orient the lobe so its long axis (Y) aligns with the direction
        const up = new THREE.Vector3(0, 1, 0);
        const quat = new THREE.Quaternion().setFromUnitVectors(up, direction.clone().normalize());
        lobe.quaternion.copy(quat);

        lobe.position.copy(position);
        lobe.scale.set(0.01, 0.01, 0.01);
        scene.add(lobe);
        lobes.push(lobe);

        new TWEEN.Tween(lobe.scale)
          .to({ x: 1, y: 1, z: 1 }, 300)
          .easing(TWEEN.Easing.Quadratic.Out)
          .start();
      }

      function onClick(event) {
        if (!renderer.xr.isPresenting) return;

        tap.x = (event.clientX / window.innerWidth) * 2 - 1;
        tap.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(tap, camera);
        const intersects = raycaster.intersectObjects([centralSphere, ...lobes]);

        if (intersects.length > 0) {
          const intersect = intersects[0];

          if (intersect.object === centralSphere && lobes.length < 6) {
            const localPoint = intersect.point.clone().sub(centralSphere.position).normalize();
            const lobePos = centralSphere.position.clone().add(localPoint.clone().multiplyScalar(lobeDistance));
            createLobe(lobePos, localPoint);
            repelLobes3D();
          } else if (intersect.object.userData.isLobe) {
            const index = lobes.indexOf(intersect.object);
            if (index > -1) {
              const lobe = lobes[index];
              lobes.splice(index, 1);

              new TWEEN.Tween(lobe.scale)
                .to({ x: 0.01, y: 0.01, z: 0.01 }, 300)
                .easing(TWEEN.Easing.Quadratic.In)
                .onComplete(() => scene.remove(lobe))
                .start();

              repelLobes3D();
            }
          }
        }
      }

      function onSelect() {
        // no-op
      }

      function onTouchStart(event) {
        if (event.touches.length === 2) {
          touchStartRotation = camera.rotation.clone();
          touchStartPosition = new THREE.Vector2(event.touches[0].clientX, event.touches[0].clientY);
        }
      }

      function onTouchMove(event) {
        if (event.touches.length === 2) {
          const touchMovePosition = new THREE.Vector2(event.touches[0].clientX, event.touches[0].clientY);
          const delta = touchMovePosition.clone().sub(touchStartPosition);
          const rotationFactor = 0.005;

          camera.rotation.set(
            touchStartRotation.x - delta.y * rotationFactor,
            touchStartRotation.y + delta.x * rotationFactor,
            0
          );

          event.preventDefault();
        }
      }

      function onTouchEnd(event) {
        if (event.touches.length < 2) {
          touchStartRotation = null;
          touchStartPosition = null;
        }
      }

      function repelLobes3D() {
        const count = lobes.length;
        if (count === 0) return;

        lobes.forEach((lobe, i) => {
          let x, y, z;

          if (count === 1) {
            x = Math.PI * i;
            y = 0;
            z = 0;
          } else if (count === 2) {
            // Two lobes placed parallel to the ground
            x = Math.cos(i * Math.PI);
            y = Math.sin(i * Math.PI);
            z = 0;
          } else if (count === 3) {
            // Three lobes evenly spaced in a plane (120 degrees apart), one perpendicular to the ground
            const angle = (2 * Math.PI) / 3;
            x = Math.cos(i * angle);
            y = Math.sin(i * angle);
            z = (i === 0) ? 1 : 0; // First lobe is perpendicular to the ground
          } else if (count === 4) {
            // Four lobes in a tetrahedral configuration, spaced 109.5 degrees apart
            const angle = Math.PI * (i === 0 ? 1 : 0);
            const radius = Math.sin(Math.PI / 3);
            const height = Math.cos(Math.PI / 3);
            const base = Math.cos(Math.PI / 3);

            if (i === 0) {
              x = 0;
              y = height;
              z = 0;
            } else if (i === 1) {
              x = -radius;
              y = -base;
              z = 0;
            } else if (i === 2) {
              x = radius;
              y = -base;
              z = 0;
            } else {
              x = 0;
              y = -height;
              z = 0;
            }
          } else if (count === 5) {
            // Five lobes: three in a plane, 120 degrees apart; two above/below (90 degrees away)
            if (i < 3) {
              const angle = (2 * Math.PI) / 3;
              x = Math.cos(i * angle);
              y = Math.sin(i * angle);
              z = 0;
            } else {
              // Place two lobes above and below
              const angle = Math.PI * (i === 3 ? 1 : -1);
              x = 0;
              y = Math.cos(angle);
              z = Math.sin(angle);
            }
          } else if (count === 6) {
            // Six lobes evenly spaced in a circle (90 degrees apart)
            const angle = (2 * Math.PI) / 6;
            x = Math.cos(i * angle);
            y = Math.sin(i * angle);
            z = 0;
          }

          const direction = new THREE.Vector3(x, y, z).normalize();
          const targetPos = centralSphere.position.clone().add(direction.clone().multiplyScalar(lobeDistance));

          new TWEEN.Tween(lobe.position)
            .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 300)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();

          // Also rotate to align to new direction
          const up = new THREE.Vector3(0, 1, 0);
          const quat = new THREE.Quaternion().setFromUnitVectors(up, direction);
          lobe.quaternion.copy(quat);
        });
      }
    </script>
  </body>
</html>
