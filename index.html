<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR VSEPR Ball and Stick Model</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
      import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

      let scene, camera, renderer, controller;
      const atoms = [];
      const sticks = [];
      const atomDistance = 0.1;
      const sphereRadius = 0.05;
      let centralSphere;
      let touchStart = null;

      const raycaster = new THREE.Raycaster();
      const tap = new THREE.Vector2();
      const group = new THREE.Group();

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        window.addEventListener('click', onClick);
        window.addEventListener('touchstart', onTouchStart, false);
        window.addEventListener('touchmove', onTouchMove, false);

        renderer.setAnimationLoop(() => {
          TWEEN.update();
          renderer.render(scene, camera);
        });

        centralSphere = createSphere(new THREE.Vector3(0, 0, -0.5), 0x0000ff);
        group.add(centralSphere);
        scene.add(group);
      }

      function createSphere(position, color = 0xff0000, radius = sphereRadius) {
        const geometry = new THREE.SphereGeometry(radius, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        return sphere;
      }

      function createStick(start, end) {
        const direction = new THREE.Vector3().subVectors(end, start);
        const length = direction.length();
        const geometry = new THREE.CylinderGeometry(0.005, 0.005, length, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const stick = new THREE.Mesh(geometry, material);

        stick.position.copy(start).add(end).multiplyScalar(0.5);
        stick.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          direction.clone().normalize()
        );

        return stick;
      }

      function onClick(event) {
        if (!renderer.xr.isPresenting) return;

        tap.x = (event.clientX / window.innerWidth) * 2 - 1;
        tap.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(tap, camera);
        const intersects = raycaster.intersectObjects([centralSphere, ...atoms]);

        if (intersects.length > 0) {
          const intersect = intersects[0];

          if (intersect.object === centralSphere && atoms.length < 6) {
            const directions = getVSEPRDirections(atoms.length + 1);
            updateGeometry(directions);
          } else {
            const index = atoms.indexOf(intersect.object);
            if (index > -1) {
              group.remove(atoms[index]);
              group.remove(sticks[index]);
              atoms.splice(index, 1);
              sticks.splice(index, 1);
              const directions = getVSEPRDirections(atoms.length);
              updateGeometry(directions);
            }
          }
        }
      }

      function getVSEPRDirections(count) {
        const directions = [];
        switch (count) {
          case 1:
            directions.push(new THREE.Vector3(0, 1, 0));
            break;
          case 2:
            directions.push(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 1));
            break;
          case 3:
            directions.push(
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(Math.sqrt(3) / 2, -0.5, 0),
              new THREE.Vector3(-Math.sqrt(3) / 2, -0.5, 0)
            );
            break;
          case 4:
            directions.push(
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(1, -1, 1).normalize(),
              new THREE.Vector3(-1, -1, 1).normalize(),
              new THREE.Vector3(0, -1, -1).normalize()
            );
            break;
          case 5:
            directions.push(
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(1, 0, 0),
              new THREE.Vector3(-1, 0, 0),
              new THREE.Vector3(0, 0, 1),
              new THREE.Vector3(0, 0, -1)
            );
            break;
          case 6:
            directions.push(
              new THREE.Vector3(1, 0, 0),
              new THREE.Vector3(-1, 0, 0),
              new THREE.Vector3(0, 1, 0),
              new THREE.Vector3(0, -1, 0),
              new THREE.Vector3(0, 0, 1),
              new THREE.Vector3(0, 0, -1)
            );
            break;
        }
        return directions;
      }

      function updateGeometry(directions) {
        atoms.forEach(atom => group.remove(atom));
        sticks.forEach(stick => group.remove(stick));
        atoms.length = 0;
        sticks.length = 0;

        directions.forEach(dir => {
          const stickEnd = centralSphere.position.clone().add(dir.clone().multiplyScalar(atomDistance));
          const stickMid = centralSphere.position.clone().add(dir.clone().multiplyScalar(atomDistance / 2));

          const atom = createSphere(stickEnd, 0xff0000, 0.025);
          const stick = createStick(centralSphere.position, stickEnd);

          group.add(atom);
          group.add(stick);
          atoms.push(atom);
          sticks.push(stick);
        });
      }

      function onTouchStart(e) {
        if (e.touches.length === 2) {
          touchStart = [e.touches[0].clientX, e.touches[1].clientX];
        } else if (e.touches.length === 1) {
          touchStart = [e.touches[0].clientX, e.touches[0].clientY];
        }
      }

      function onTouchMove(e) {
        if (e.touches.length === 2 && touchStart) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const prevDx = touchStart[0] - touchStart[1];
          const delta = (dx - prevDx) * 0.005;
          group.rotation.y += delta;
          touchStart = [e.touches[0].clientX, e.touches[1].clientX];
        } else if (e.touches.length === 1 && touchStart) {
          const deltaX = e.touches[0].clientX - touchStart[0];
          const deltaY = e.touches[0].clientY - touchStart[1];
          group.rotation.y += deltaX * 0.005;
          group.rotation.x += deltaY * 0.005;
          touchStart = [e.touches[0].clientX, e.touches[0].clientY];
        }
      }

      function onSelect() {}
    </script>
  </body>
</html>
